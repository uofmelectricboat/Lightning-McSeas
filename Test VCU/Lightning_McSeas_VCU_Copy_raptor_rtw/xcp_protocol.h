/*****************************************************************************
   xcp_protocol.h
   Generated By:
   Raptor 2021b_1.0.14409 (6115)
   Matlab (R2021b) 9.11

   Copyright (c) 2018 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Mon May 16 16:32:25 2022
 *****************************************************************************/

/********************
   xcpcan_auto_conf_priv.h
   Generated by Raptor Mon May 16 16:32:25 2022
   XCP Protocol Parameters
   CAN BUS 	: CAN1
   BCID		: 0x100
   BCID TYPE	: Standard
   RXID 		: 0x200
   RXID TYPE	: Standard
   TXID		: 0x300
   TXID TYPE	: Standard
   DAQ RATES	: [50.0, 100.0, 500.0, 1000.0]
   NUM ODTs	: 20.0
   UPDATE RATE	: 25
   NUM DAQs	: 4
 *********************/
#ifndef _XCPCAN_AUTO_CONFPRIV_H
#define _XCPCAN_AUTO_CONFPRIV_H
#include "rtwtypes.h"

/******************************************************************************
 *
 * Preprocessor definitions
 *
 ******************************************************************************/
#define XCP_PACK( type )               type
#define XCP_CONFIG_TYPE                const
#define XCP_STATE_TYPE
#define XCP_FN_TYPE

extern unsigned long Xcp_SavedMsr;

#define XCP_EE_BIT_OFFSET              (15u)
#define XCP_DISABLE_ALL_INTERRUPTS()   Xcp_SavedMsr = Xcp_GetMsr(); Xcp_DisableEeBit();
#define XCP_ENABLE_ALL_INTERRUPTS()    if( Xcp_SavedMsr & ( (uint32_T)(1u << XCP_EE_BIT_OFFSET) ) ) { Xcp_EnableEeBit(); } Xcp_msync(); Xcp_isync();
#define sizeof_Xcp_OdtEntryCfg_t       1
#define sizeof_Xcp_NvDaqState_t        6
#define sizeof_Xcp_NvSession_t         12
#define sizeof_Xcp_DaqDynConfig_t      ( XCP_MAX_ODT_ENTRIES_DYNDAQ + 1)
#define XCP_ODTENTRY_SINGLE_BIT        0x80
#define XCP_ODTENTRY_BITOFFSET_MASK    0x07
#define XCP_PACK_ODTENTRYCFG_BYTE(                               /* uint32 */addr, /* uint8 */addrExt, /* uint8 */numBytes ) ( numBytes )
#define XCP_PACK_ODTENTRYADDR_BYTE(                              /* uint32 */addr, /* uint8 */addrExt, /* uint8 */numBytes ) ( (Xcp_OdtEntryAddr_t)( addr ) )
#define XCP_PACK_ODTENTRYCFG_BIT(                                /* uint32 */addr, /* uint8 */addrExt, /* uint8 */bitOffset ) ( XCP_ODTENTRY_SINGLE_BIT | ( bitOffset ) )
#define XCP_UNPACK_ODTENTRY_NUMBYTES(                            /* Xcp_OdtEntryAddr_t */odtEntryAddr, /* uint8 */odtEntryCfg ) ( odtEntryCfg )
#define XCP_UNPACK_ODTENTRY_BYTEADDR(                            /* Xcp_OdtEntryAddr_t */odtEntryAddr, /* uint8 */odtEntryCfg ) ( (Xcp_Addr_t)( odtEntryAddr ) )
#define XCP_UNPACK_ODTENTRY_BITOFFSET(                           /* Xcp_OdtEntryAddr_t */odtEntryAddr, /* uint8 */odtEntryCfg ) ( ( odtEntryCfg ) & XCP_ODTENTRY_BITOFFSET_MASK )

typedef uint8_T* Xcp_Addr_t;
/* The type used for all pointers to DAQ, STIM or calibration memory. It must have a width of 1 byte. */
typedef uint8_T* Xcp_OdtEntryAddr_t;
             /* The type of the "ODT entry address" (see the comments above). */
typedef uint8_T XcpCan_MsgObjId_t;    /* The type of a CAN message object ID. */
typedef XCP_CONFIG_TYPE uint8_T* Xcp_CfgPtr8;
       /* Instances of this type refer to a location of type XCP_CONFIG_TYPE. */
typedef XCP_CONFIG_TYPE uint16_T* Xcp_CfgPtr16;
       /* Instances of this type refer to a location of type XCP_CONFIG_TYPE. */
typedef XCP_CONFIG_TYPE uint32_T* Xcp_CfgPtr32;
       /* Instances of this type refer to a location of type XCP_CONFIG_TYPE. */
typedef XCP_STATE_TYPE uint8_T* Xcp_StatePtr8;
        /* Instances of this type refer to a location of type XCP_STATE_TYPE. */
typedef XCP_STATE_TYPE uint16_T* Xcp_StatePtr16;
        /* Instances of this type refer to a location of type XCP_STATE_TYPE. */
typedef XCP_STATE_TYPE uint32_T* Xcp_StatePtr32;
        /* Instances of this type refer to a location of type XCP_STATE_TYPE. */

/* We do not define typedefs for uint* and sint* since all instances of these types contain the address of a location on the stack,
 * which is assumed to be in the default memory space. */
typedef uint8_T Xcp_Seed_t;            /* The seed is an array of this type. */
typedef uint8_T Xcp_Key_t;        /* The key buffer is an array of this type. */
uint8_T* Xcp_MemCopy ( uint8_T* pDest, const uint8_T* pSrc, uint32_T numBytes );
void Xcp_MemZero ( uint8_T* pMemory, uint32_T numBytes );
int32_T Xcp_CheckCanId ( uint32_T canMsgId );

#define XCP0_CAN_NUM_CHANNELS          7
#define XCP_CAN_RX_CMD_NUMBUF          4
#define XCP_CAN_RX_CMD_START           0
#define XCP_CAN_RX_CMD_END             3
#define XCP_CAN_TX_EVENT_NUMBUF        1
#define XCP_CAN_TX_EVENT_START         4
#define XCP_CAN_TX_EVENT_END           4
#define XCP_CAN_TX_CRM_NUMBUF          1
#define XCP_CAN_TX_CRM_START           5
#define XCP_CAN_TX_CRM_END             5
#define XCP_CAN_MAX_TXMSGOBJID         1
#define XCP0_CAN_BROADCAST_MSGID       0x100
#define XCP0_CAN_RX_MSGID              0x200
#define XCP0_CAN_TX_MSGID              0x300
#define XCP0_CAN_DYNDAQ_MSGID          0x300

/*******************************************************************from xcp_auto_confdefs.h***********
 *
 * General definitions
 *
 ******************************************************************************/
#define XCP_V_1_0_5
#define XCP_ENABLE
#define XCP_ON_CAN
#define XCP_NUM_SESSIONS               1
#define XCP_ENABLE_SEEDNKEY
#define XCP_ENABLE_PGM
#define XCP_ENABLE_CALPAG

//#define XCP_ENABLE_RESUME
#define XCP_ENABLE_OPTIONAL_CMDS
#define XCP_ENABLE_STIM
#define XCP_ENABLE_DYNDAQ
#define XCP_ENABLE_PAGEFREEZE
#define XCP_POLL_INTERVAL              25                        /* Measured in ms */
#define XCP_BLOCK_SEPARATION_TIME      25                        /* Measured in ms */
#define XCP_TIMESTAMP_UNIT             6                         /* See specification of GET_DAQ_RESOLUTION_INFO command. */
#define XCP_TIMESTAMP_TICKS            1                         /* See specification of GET_DAQ_RESOLUTION_INFO command. */
#define XCP_MAX_CHECKSUM_BLOCKSIZE     0xffff                    /* The maximum possible block size for a checksum calculated with BUILD_CHECKSUM. */
#define XCPCAN_ALLOW_EXTENDED_MSG_IDS  1                         /* 1 = allow extended CAN msg IDs; 0 = do not. */
#define ADDRESS_EXTENSION_FREE         0                         /* Address extension can be different within one and the same ODT. */
#define ADDRESS_EXTENSION_ODT          1                         /* Address extension must be the same for all entries within one ODT. */
#define ADDRESS_EXTENSION_DAQ          3                         /* Address extension must be the same for all entries within one DAQ. */
#define XCP_ADDR_EXTENSION_TYPE        ADDRESS_EXTENSION_DAQ
#define XCP_ENV_NOT_ETAS
#define XCP_ATOMIC_DATA_SAMPLING_PER_ODT

/* XCP resources which are available in principle, though they may be locked. */
#define XCP_RESOURCES_AVAILABLE        XCP_RESOURCE_CAL_PAG | XCP_RESOURCE_DAQ
#define XCP0_MAXCTO                    8
#define XCP0_MAXDTO                    8

/******************************************************************************
 *
 * Per-session DAQ definitions
 *
 ******************************************************************************/
#define XCP0_NUM_STATIC_DAQ            0
#define XCP0_NUM_DYN_DAQ               4
#define XCP0_NUM_ALL_DAQ               ( XCP0_NUM_STATIC_DAQ + XCP0_NUM_DYN_DAQ )
#define XCP0_NUM_ODT_ENTRIES_DYNDAQ    7
#define XCP0_NUM_ODT_DYNDAQ            20                        /* Max ODT per DAQ list */
#define XCP0_FIRST_PID_DYNDAQ0         0
#define XCP0_DYNDAQ0_START             0
#define XCP0_DYNDAQ0_END               139
#define XCP0_CAN_DYNDAQ0_NUMBUF        20
#define XCP0_CAN_DYNDAQ0_START         6
#define XCP0_CAN_DYNDAQ0_END           25
#define XCP0_FIRST_PID_DYNDAQ1         20
#define XCP0_DYNDAQ1_START             140
#define XCP0_DYNDAQ1_END               279
#define XCP0_CAN_DYNDAQ1_NUMBUF        20
#define XCP0_CAN_DYNDAQ1_START         26
#define XCP0_CAN_DYNDAQ1_END           45
#define XCP0_FIRST_PID_DYNDAQ2         40
#define XCP0_DYNDAQ2_START             280
#define XCP0_DYNDAQ2_END               419
#define XCP0_CAN_DYNDAQ2_NUMBUF        20
#define XCP0_CAN_DYNDAQ2_START         46
#define XCP0_CAN_DYNDAQ2_END           65
#define XCP0_FIRST_PID_DYNDAQ3         60
#define XCP0_DYNDAQ3_START             420
#define XCP0_DYNDAQ3_END               559
#define XCP0_CAN_DYNDAQ3_NUMBUF        20
#define XCP0_CAN_DYNDAQ3_START         66
#define XCP0_CAN_DYNDAQ3_END           85
#define XCP0_CAN_QUEUEALL_NUMBUF       86
#define XCP0_ODT_LIST_SIZE             560
#define XCP_MAX_ODT_ENTRIES_DYNDAQ     20

/******************************************************************************
 *
 * Non-volatile RAM definitions
 *
 ******************************************************************************/
#define XCP0_DAQ_NVRAM_SIZE            ( 0 + 3 * ( sizeof_Xcp_NvDaqState_t + sizeof_Xcp_DaqDynConfig_t + XCP0_NUM_ODT_ENTRIES_DYNDAQ * XCP0_NUM_ODT_DYNDAQ * ( sizeof( Xcp_OdtEntryAddr_t ) + sizeof_Xcp_OdtEntryCfg_t ) ) + 3 * 4 )
#define XCP_INVALID_NV_IDX             ( (uint32_T)0xffffffff )
#define XCP0_NV_START_IDX              0
#define XCP_NV_REGION_SIZE             ( XCP0_NV_START_IDX + sizeof_Xcp_NvSession_t + XCP0_DAQ_NVRAM_SIZE )

/******************************************************************************
 *
 * Preprocessor definitions
 *
 ******************************************************************************/
#define XCPCAN_INVALID_MSGID           (0xffffffff)
#define XCPCAN_INVALID_MSGOBJID        (XcpCan_MsgObjId_t)(0xffffffff)

/* Transport layer command subcodes. */
#define XCPCAN_CMD_GET_SLAVE_ID        0xFF
#define XCPCAN_CMD_GET_DAQ_ID          0xFE
#define XCPCAN_CMD_SET_DAQ_ID          0xFD

/******************************************************************************
 *
 * Type definitions
 *
 ******************************************************************************/
/* This holds the state of an instance of XcpCan_QueueBuf_t. The lower 4 bits contain a value from XcpCan_QueueBufStates_t.
 * If this value is XCPCAN_TXNOTSENT or XCPCAN_TXINPROGRESS the upper 4 bits indicate the number of bytes currently used in
 * the associated instance of XcpCan_QueueBuf_t. */
typedef XCP_STATE_TYPE uint8_T XcpCan_QueueBufProps_t;

/* This holds a CAN message ID which was assigned to a dynamic DAQ list at runtime. */
typedef XCP_STATE_TYPE uint32_T XcpCan_DynDaqMsgId_t;
typedef enum {
  XCPCAN_TXRXFREE = 0,     /* The buffer is available to store TX or RX data. */
  XCPCAN_TXALLOC,
  /* The buffer has been allocated to store TX data, but it is not yet ready to be transmitted. */
  XCPCAN_TXNOTSENT,                 /* The buffer is ready to be transmitted. */
  XCPCAN_TXINPROGRESS,                 /* The buffer is being transmitted. */
  XCPCAN_RXDATA                        /* The buffer is contains RX data. */
} XcpCan_QueueBufStates_t;

typedef struct {
  uint32_T msgBuffer[2];
  /* We need 8 bytes of storage aligned on a natural boundary, and this is a convenient way to allocate it. */
} XcpCan_QueueBuf_t;

typedef XCP_STATE_TYPE struct {
  uint32_T ctXcpPos;
  uint32_T ctCanPos;
} XcpCan_QueuePos_t;

typedef XCP_CONFIG_TYPE struct {
  uint32_T idxStart;
  /* The first element of this channel's queue space in the array pointed to by XcpCan_SessionCfg_t::pQueueBuffers */
  uint32_T idxEnd;
  /* The last element of this channel's queue space in the array pointed to by XcpCan_SessionCfg_t::pQueueBuffers */
  uint32_T msgId;
  /* The CAN message ID used for sending or receiving messages on this channel. If this channel is used for a dynamic DAQ list, this may be overridden at runtime. */
  XcpCan_MsgObjId_t msgObjId;
         /* The CAN message object used for sending messages on this channel. */
} XcpCan_ChannelCfg_t;

typedef XCP_CONFIG_TYPE struct {
  XcpCan_ChannelCfg_t* pChannelCfgs;
                            /* Points to an array with one entry per channel. */
  XcpCan_QueuePos_t* pQueuePositions;
                            /* Points to an array with one entry per channel. */
  XcpCan_QueueBuf_t* pQueueBuffers;
                      /* Points to an array with one entry per queue element. */
  XcpCan_QueueBufProps_t* pQueueBufferStates;
                      /* Points to an array with one entry per queue element. */
  XcpCan_DynDaqMsgId_t* pDynDaqMsgIds;
                         /* The CAN msg IDs configured for dynamic DAQ lists. */
  uint32_T broadcastMsgId;
                         /* The CAN msg ID configured for broadcast messages. */
  uint16_T numChannels;
  uint16_T firstRxStimChannel;
                /* The first channel corresponding to a STIM or DAQ/STIM list */
  uint16_T lastTxChannel;
                  /* The last channel corresponding to a DAQ or DAQ/STIM list */
} XcpCan_SessionCfg_t;

typedef XCP_STATE_TYPE struct {
  uint8_T echoRequested;
         /* Indicates whether the GET_SLAVE_ID command has requested an echo. */
} XcpCan_Session_t;

#ifdef XCP_ENABLE_SEEDNKEY

typedef void (*XCPSecurityFn)(uint8_T resource, uint8_T* pSeedLen, uint8_T
  ** ppSeed, uint8_T* pKeyLen, uint8_T** ppKey);

#endif

/******************************************************************************
 *
 * Extern declarations
 *
 ******************************************************************************/
extern XCP_STATE_TYPE uint8_T XcpCan_TxPendingOnMsgObj[];
extern void XcpCan_TxCallback(XcpCan_MsgObjId_t msgObjId);

/******************************************************************************
 *
 * Preprocessor definitions
 *
 ******************************************************************************/
#define XCP_PROTOCOL_VERSION           0x01
#define XCP_DRIVER_VERSION_MAJOR       0x01
#define XCP_DRIVER_VERSION_MINOR       0x00

/* Transport layers */
#define XCP_TRANSPORTLAYER_CAN         0x01ul

/* Standard commands */
#define XCP_CMD_CONNECT                0xFF
#define XCP_CMD_DISCONNECT             0xFE
#define XCP_CMD_GET_STATUS             0xFD
#define XCP_CMD_SYNCH                  0xFC
#define XCP_CMD_GET_COMM_MODE_INFO     0xFB
#define XCP_CMD_GET_ID                 0xFA
#define XCP_CMD_SET_REQUEST            0xF9
#define XCP_CMD_GET_SEED               0xF8
#define XCP_CMD_UNLOCK                 0xF7
#define XCP_CMD_SET_MTA                0xF6
#define XCP_CMD_UPLOAD                 0xF5
#define XCP_CMD_SHORT_UPLOAD           0xF4
#define XCP_CMD_BUILD_CHECKSUM         0xF3
#define XCP_CMD_TRANSPORT_LAYER_CMD    0xF2
#define XCP_CMD_USER_CMD               0xF1

/* Calibration commands */
#define XCP_CMD_DOWNLOAD               0xF0
#define XCP_CMD_DOWNLOAD_NEXT          0xEF
#define XCP_CMD_DOWNLOAD_MAX           0xEE
#define XCP_CMD_SHORT_DOWNLOAD         0xED
#define XCP_CMD_MODIFY_BITS            0xEC

/* Page switching commands */
#define XCP_CMD_SET_CAL_PAGE           0xEB
#define XCP_CMD_GET_CAL_PAGE           0xEA
#define XCP_CMD_GET_PAG_PROCESSOR_INFO 0xE9
#define XCP_CMD_GET_SEGMENT_INFO       0xE8
#define XCP_CMD_GET_PAGE_INFO          0xE7
#define XCP_CMD_SET_SEGMENT_MODE       0xE6
#define XCP_CMD_GET_SEGMENT_MODE       0xE5
#define XCP_CMD_COPY_CAL_PAGE          0xE4

/* Data acquisition and stimulation commands */
#define XCP_CMD_CLEAR_DAQ_LIST         0xE3
#define XCP_CMD_SET_DAQ_PTR            0xE2
#define XCP_CMD_WRITE_DAQ              0xE1
#define XCP_CMD_SET_DAQ_LIST_MODE      0xE0
#define XCP_CMD_GET_DAQ_LIST_MODE      0xDF
#define XCP_CMD_START_STOP_DAQ_LIST    0xDE
#define XCP_CMD_START_STOP_SYNCH       0xDD
#define XCP_CMD_GET_DAQ_CLOCK          0xDC
#define XCP_CMD_READ_DAQ               0xDB
#define XCP_CMD_GET_DAQ_PROCESSOR_INFO 0xDA
#define XCP_CMD_GET_DAQ_RESOLUTION_INFO 0xD9
#define XCP_CMD_GET_DAQ_LIST_INFO      0xD8
#define XCP_CMD_GET_DAQ_EVENT_INFO     0xD7
#define XCP_CMD_FREE_DAQ               0xD6
#define XCP_CMD_ALLOC_DAQ              0xD5
#define XCP_CMD_ALLOC_ODT              0xD4
#define XCP_CMD_ALLOC_ODT_ENTRY        0xD3

/* Non-volatile memory programming commands */
#define XCP_CMD_PROGRAM_START          0xD2
#define XCP_CMD_PROGRAM_CLEAR          0xD1
#define XCP_CMD_PROGRAM                0xD0
#define XCP_CMD_PROGRAM_RESET          0xCF
#define XCP_CMD_GET_PGM_PROCESSOR_INFO 0xCE
#define XCP_CMD_GET_SECTOR_INFO        0xCD
#define XCP_CMD_PROGRAM_PREPARE        0xCC
#define XCP_CMD_PROGRAM_FORMAT         0xCB
#define XCP_CMD_PROGRAM_NEXT           0xCA
#define XCP_CMD_PROGRAM_MAX            0xC9
#define XCP_CMD_PROGRAM_VERIFY         0xC8

/* This is a special value for Xcp_Session_t::prevCmd which indicates that the previous command was in fact
 * the current command, i.e. the command is being processed a second time. */
#define XCP_CMD_CURR_CMD               0x01

/* Event codes. */
#define XCP_EV_RESUME_MODE             0x00
#define XCP_EV_CLEAR_DAQ               0x01
#define XCP_EV_STORE_DAQ               0x02
#define XCP_EV_STORE_CAL               0x03
#define XCP_EV_CMD_PENDING             0x05
#define XCP_EV_DAQ_OVERLOAD            0x06
#define XCP_EV_SESSION_TERMINATED      0x07
#define XCP_EV_USER                    0xFE
#define XCP_EV_TRANSPORT               0xFF

/* Error codes. */
#define XCP_ERR_CMD_SYNCH              0x00
#define XCP_ERR_CMD_BUSY               0x10
#define XCP_ERR_DAQ_ACTIVE             0x11
#define XCP_ERR_PGM_ACTIVE             0x12
#define XCP_ERR_CMD_UNKNOWN            0x20
#define XCP_ERR_CMD_SYNTAX             0x21
#define XCP_ERR_OUT_OF_RANGE           0x22
#define XCP_ERR_WRITE_PROTECTED        0x23
#define XCP_ERR_ACCESS_DENIED          0x24
#define XCP_ERR_ACCESS_LOCKED          0x25
#define XCP_ERR_PAGE_NOT_VALID         0x26
#define XCP_ERR_MODE_NOT_VALID         0x27
#define XCP_ERR_SEGMENT_NOT_VALID      0x28
#define XCP_ERR_SEQUENCE               0x29
#define XCP_ERR_DAQ_CONFIG             0x2A
#define XCP_ERR_MEMORY_OVERFLOW        0x30
#define XCP_ERR_GENERIC                0x31
#define XCP_ERR_VERIFY                 0x32

/* Receive PIDs */
#define XCP_PID_CMD_FIRST              0xFF
#define XCP_PID_CMD_LAST               0xC0
#define MAX_CALPAGCMD_PID              0xF0
#define MAX_DAQCMD_PID                 0xE3
#define MAX_PGMCMD_PID                 0xD2

/* Other PIDs are for STIM-data */
/* Transmit PIDs */
#define XCP_PID_SERVICE_REQUEST        0xFC
#define XCP_PID_EVENT                  0xFD
#define XCP_PID_ERROR                  0xFE
#define XCP_PID_RESPONSE               0xFF

/* Other PIDs are for DAQ-data */
/* Resources (for seed & key) */
#define XCP_RESOURCE_CAL_PAG           0x01
#define XCP_RESOURCE_DAQ               0x04
#define XCP_RESOURCE_STIM              0x08
#define XCP_RESOURCE_PGM               0x10

/* Session states */
#define XCP_SESSION_STATE_STORE_CAL    0x01
#define XCP_SESSION_STATE_STORE_DAQ    0x04
#define XCP_SESSION_STATE_CLEAR_DAQ    0x08
#define XCP_SESSION_STATE_PGM          0x10                      /* The XCP specification states that this bit position is unused, so we use it for our own purposes. */
#define XCP_SESSION_STATE_DAQ_RUNNING  0x40
#define XCP_SESSION_STATE_RESUME       0x80

/* XCP checksum types */
#define XCP_CHECKSUM_TYPE_ADD_11       0x01
#define XCP_CHECKSUM_TYPE_ADD_12       0x02
#define XCP_CHECKSUM_TYPE_ADD_14       0x03
#define XCP_CHECKSUM_TYPE_ADD_22       0x04
#define XCP_CHECKSUM_TYPE_ADD_24       0x05
#define XCP_CHECKSUM_TYPE_ADD_44       0x06
#define XCP_CHECKSUM_TYPE_CRC_16       0x07
#define XCP_CHECKSUM_TYPE_CRC_16_CITT  0x08
#define XCP_CHECKSUM_TYPE_CRC_32       0x09
#define XCP_CHECKSUM_TYPE_USER         0xFF

/* return values for command functions */
#define XCP_RX_READY                   0x01ul
#define XCP_TX_READY                   0x02ul

/* Daq */
#define XCP_DAQLIST_UNDEF              0xFFFF
#define XCP_DAQLIST_START              0x01
#define XCP_DAQLIST_STOP               0x00
#define XCP_DAQLIST_SELECT             0x02
#define XCP_DAQLIST_SYNC_STOPALL       0x00
#define XCP_DAQLIST_SYNC_STARTSEL      0x01
#define XCP_DAQLIST_SYNC_STOPSEL       0x02

/* The bits of DAQ list mode. */
#define XCP_DAQLISTMODE_RESUME         0x80
#define XCP_DAQLISTMODE_RUNNING        0x40
#define XCP_DAQLISTMODE_PIDOFF         0x20
#define XCP_DAQLISTMODE_TIMESTAMP      0x10
#define XCP_DAQLISTMODE_DIRECTION      0x02
#define XCP_DAQLISTMODE_SELECTED       0x01

/* Values which indicate properties of a DAQ list. */
#define XCP_DAQLISTPROPERTY_DAQ        0x01                      /* The list is available for DAQ. */
#define XCP_DAQLISTPROPERTY_STIM       0x02                      /* The list is available for STIM. */
#define XCP_DAQLISTPROPERTY_DAQ_STIM   ( XCP_DAQLISTPROPERTY_DAQ | XCP_DAQLISTPROPERTY_STIM )
#define XCP_DAQLISTPROPERTY_EVENTFIXED 0x04                      /* The event associated with the DAQ list cannot be changed. */

/* Segment modes. */
#define XCP_SEGMODE_FREEZE             0x01
#define XCP_SEGMODE_FREEZE_PENDING     0x80                      /* The XCP specification states that this bit position is unused, so we use it for our own purposes. */

/* Endian-ness */
#define XCP_BYTE_ORDER_LITTLE_ENDIAN   0                         /* We must use this value since it is mandated by the XCP specification. */
#define XCP_BYTE_ORDER_BIG_ENDIAN      1                         /* We must use this value since it is mandated by the XCP specification. */

/* This number is written at the start of every block of session data which is stored in non-volatile memory during RESUME mode.
 * Its presence indicates that a valid session data block follows it in memory. */
#define XCP_NVMEM_MAGIC_NUMBER         0xdeadbeef

/* These are helper macros to access the transport-layer-specific state and configuration of a session. The transport-layer-specific
 * state and configuration is stored in this manner to allow uniform access, irrespective of the definition of the structures which
 * contain the state and configuation. */
#define XCPCAN_SESSIONCFG( sessionId ) ( (XcpCan_SessionCfg_t*)(Xcp_SessionConfigs[ sessionId ].pTransportCfg ) )
#define XCPCAN_SESSION( sessionId )    ( (XcpCan_Session_t*)(Xcp_SessionConfigs[ sessionId ].pTransport ) )
#define XCPIP_SESSIONCFG( sessionId )  ( (XcpIp_SessionCfg_t*)(Xcp_SessionConfigs[ sessionId ].pTransportCfg ) )
#define XCPIP_SESSION( sessionId )     ( (XcpIp_Session_t*)(Xcp_SessionConfigs[ sessionId ].pTransport ) )

/* For each session, the transport layer's channels are organised as follows:
 *
 *      CMD channel
 *      EV channel
 *      RESP channel
 *      DAQ list channel
 *      DAQ list channel
 *      DAQ list channel
 *      */
#define XCP_RX_CMD_CHANNEL             0
#define XCP_TX_EVENT_CHANNEL           1
#define XCP_TX_CRM_CHANNEL             2
#define XCP_FIRST_DAQ_CHANNEL          3
#define XCP_FIRST_TX_CHANNEL           XCP_TX_EVENT_CHANNEL

/******************************************************************************
 *
 * Type definitions
 *
 ******************************************************************************/
/* This type holds the configuration of an ODT entry. In some circumstances it can also hold part of the address associated with
 * the ODT entry. */
typedef XCP_STATE_TYPE uint8_T Xcp_OdtEntryCfg_t;

/* This type represent the session data stored in non-volatile (NV) memory for RESUME mode. */
typedef struct {
  uint32_T magicNumber;
  /* This is always equal to XCP_NVRAM_MAGIC_NUMBER and is used to indicate that a valid session data block follows. */
  uint16_T sessionCfgId;
  uint16_T numDynDaqLists;
  uint16_T numResumeDaqLists;
} Xcp_NvSession_t;

/* This type represent the DAQ data stored in non-volatile (NV) memory for RESUME mode. */
typedef struct {
  uint8_T maxOdtIdUsed;
  uint8_T daqListMode;
  uint16_T daqListId;
  uint16_T daqEvent;
} Xcp_NvDaqState_t;

/* This type stores the ID of an XCP slave. (ID Table Rev 4) */
typedef XCP_CONFIG_TYPE struct {
  uint8_T idStringLen;
  Xcp_CfgPtr8 idString;
  Xcp_CfgPtr8 hardwareType;            //GetID 129
  Xcp_CfgPtr8 ecuAddr;                 //GetID 130
  uint8_T asamMC2StringLen;
  Xcp_CfgPtr8 asamMC2String;           //GetID 1
  uint8_T calIdTxtStringLen;
  Xcp_CfgPtr8 calIdTxt;                //GetID 131
  uint8_T buildUIDStringLen;
  Xcp_CfgPtr8 buildUID;                //GetID 132
  Xcp_CfgPtr8 bootAddr;                //GetID 133
  Xcp_CfgPtr8 bootToolAddr;            //GetID 134
} Xcp_SlaveId_t;

/* This type represents a generic XCP packet */
typedef XCP_STATE_TYPE XCP_PACK( struct {
  uint8_T pid;
  uint8_T data[1];
  /* Strictly speaking, there may be more than 1 data byte. However, we only declare
   * 1 to encourage the compiler to pack the structure on byte boundaries. This works
   * because we never declare instances of this type, only pointers to pre-allocated buffers */
} ) Xcp_Packet_t;

/* The configuration of a PAGE. */
typedef XCP_CONFIG_TYPE struct {
  uint8_T initSegment;           /* The ID of the init segment for this page. */
} Xcp_PageConfig_t;

/* The configuration of a SEGMENT. */
typedef XCP_CONFIG_TYPE struct {
  Xcp_PageConfig_t* pPageConfigs;
                          /* The configuration of the pages in this segment.  */
  uint8_T numPages;       /* The number of pages in this segment.             */
} Xcp_SegConfig_t;

/* The state of a SEGMENT. */
typedef XCP_STATE_TYPE struct {
  uint8_T mode;       /* The mode of the segment, as defined by the XCP spec  */
  uint8_T toolPage;   /* The ID of the current tool page for the segment      */
} Xcp_SegState_t;

/* The state of a DAQ list. */
typedef XCP_STATE_TYPE struct {
  uint8_T daqListMode;
                     /* The mode of the DAQ list, as defined by the XCP spec. */
  uint8_T maxOdtIdUsed;
  /* The maximum ODT ID which has been configured (via WRITE_DAQ) for this DAQ list. */
  uint16_T daqEvent;     /* The event currently associated with the DAQ list. */
} Xcp_Daq_t;

/* The configuration of a DAQ list. */
typedef XCP_CONFIG_TYPE struct {
  uint8_T firstPid;                   /* The first PID used by this DAQ list. */
  uint8_T numOdt;
  /* For a static DAQ list, the number of ODTs in the list. For a dynamic DAQ, the max number of ODTs in the list. */
  uint16_T idxDaqStart;
  /* The start of this DAQ list's section of Xcp_SessionConfig_t::pOdtEntryAddrs and Xcp_SessionConfig_t::pOdtEntryCfgs */
  uint8_T numOdtEntries;
  /* For a static DAQ, the number of ODT entries in each ODT. For a dynamic DAQ, the max number of ODT entries in each ODT. */
  uint8_T properties;
  /* Properties of the DAQ list. At least one of XCP_DAQLISTPROPERTY_DAQ or XCP_DAQLISTPROPERTY_STIM must be set. */
  uint16_T defaultEvent;  /* The default event channel used for the DAQ list. */
} Xcp_DaqConfig_t;

#ifdef XCP_ENABLE_DYNDAQ

typedef XCP_STATE_TYPE struct {
  uint8_T numOdt;
  uint8_T *odtEntryNums;
} Xcp_DaqDynConfig_t;

#endif                                 /* XCP_ENABLE_DYNDAQ */

/* The state of a session. */
typedef XCP_STATE_TYPE struct {
  Xcp_Addr_t mta;     /* Current MTA                                          */
  uint8_T sessionStatus;
  /* Current session status as defined in GET_STATUS; note the DAQ_RUNNING bit is calculated on demand */

#ifdef XCP_ENABLE_SEEDNKEY

  uint8_T ctResourceProtection;
                      /* Current resource protection: bit set = protected     */
  uint8_T unlockResource;
                      /* Resource to be unlocked with UNLOCK                  */
  uint8_T seedRemainBytes;
                      /* Number of bytes at pRemainSeed.                      */
  union {             /* This union is used to reduce storage space.          */
    Xcp_Key_t* pKey;  /* Location for UNLOCK to store next portion of key.    */
    Xcp_Seed_t* pRemainSeed;
                      /* The remaining seed to be sent via GET_SEED.          */
  } seedOrKey;

#endif

#ifdef XCP_ENABLE_RESUME

  uint16_T sessionCfgId;
           /* Unique identification of DAQ configuration; used during RESUME. */

#endif

  uint16_T ctDaqListId;
                      /* Working DAQ, set by SET_DAQ_PTR                      */
  uint8_T ctOdtId;    /* Working ODT, set by SET_DAQ_PTR                      */
  uint8_T ctOdtEntryId;
                      /* Working ODT entry, set by SET_DAQ_PTR                */
  uint8_T isConnected;/* Current connection state                             */
  uint8_T prevCmd;
  /* The PID of the previously-processed command, or XCP_CMD_CURR_CMD if the previous command is being re-processed. */
  uint8_T timeoutCounter;
                      /* Timeout counter for sending EV_CMD_PENDING           */
  uint8_T downloadRemainBytes;
  /* The number of remaining download (or flash) bytes in master block mode. */
  uint16_T numDynDaqLists;
                      /* Number of dynamic DAQ lists which have been defined. */
} Xcp_Session_t;

/* Identifiers for the supported transport layers. */
typedef enum {
  XCP_CAN = 0,
  XCP_IP
} Xcp_TransportLayer_t;

/* The configuration of a session. */
typedef XCP_CONFIG_TYPE struct {
  const void* pTransportCfg;
     /* The configuration of the transport layer associated with this session */
  void* pTransport;
             /* The state of the transport layer associated with this session */

  /* The following point to functions within the transport layer associated with the session. */
  Xcp_StatePtr8 XCP_FN_TYPE (*pGetTxBuf) ( uint32_T sessionId, uint32_T
    channelId );
  Xcp_StatePtr8 XCP_FN_TYPE (*pGetRxBuf) ( uint32_T sessionId, uint32_T
    channelId );

#ifdef XCP_ENABLE_STIM

  Xcp_StatePtr8 XCP_FN_TYPE (*pPeekRxBuf) ( uint32_T sessionId, uint32_T
    channelId, uint32_T peekIdx );

#endif

  void XCP_FN_TYPE (*pTxNext) ( uint32_T sessionId, uint32_T channelId, uint32_T
    bufferLen );
  void XCP_FN_TYPE (*pRxNext) ( uint32_T sessionId, uint32_T channelId );
  uint32_T XCP_FN_TYPE (*pCmdProc) ( uint32_T sessionId, Xcp_Packet_t* pRxPacket,
    Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );

#ifdef XCP_ENABLE_RESUME

  uint32_T XCP_FN_TYPE (*pPrepareResume) ( uint32_T sessionId, uint32_T
    daqListId, uint32_T nvIdx );
  uint32_T XCP_FN_TYPE (*pDoResume) ( uint32_T sessionId, uint32_T daqListId,
    uint32_T nvIdx );

#endif

  void XCP_FN_TYPE (*pResetDaqList) ( uint32_T sessionId, uint32_T daqListId );

  /* Each of the following two data members points to an array which has one element per ODT entry for all ODTs
   * in all DAQ lists in the session. If the session uses dynamic DAQ lists, the array has space for each DAQ list
   * to have its maximum possible number of ODTs and ODT entries. If a particular dynamic DAQ uses fewer than the
   * maximum, the array will be sparsely populated. */
  Xcp_OdtEntryAddr_t* pOdtEntryAddrs;
  /* Each element of this array gives the address associated with an ODT entry. */
  Xcp_OdtEntryCfg_t* pOdtEntryCfgs;
       /* Each element of this array gives the configuration of an ODT entry. */
  Xcp_DaqConfig_t* pDaqConfigs;
              /* An array of DAQ configurations.                              */

#ifdef XCP_ENABLE_DYNDAQ

  Xcp_DaqDynConfig_t* pDaqDynConfigs;
              /* An array of dynamic DAQ configurations.                      */

#endif

  Xcp_Daq_t* pDaqStates;
              /* An array of DAQ states.                                      */
  uint16_T numStatDaqLists;
              /* The number of static DAQ lists.                              */
  uint16_T maxDynDaqLists;
              /* The max number of dynamic DAQ lists.                         */
  uint32_T totOdtEntries;
              /* Total number of ODT entries in all ODTs in all DAQ lists     */
  uint16_T maxDtoLen;
              /* Maximum size of a DTO.                                       */
  uint8_T maxCtoLen;
              /* Maximum size of a CTO.                                       */
  uint8_T defResourceProtection;
              /* Default resource protection: bit set = protected             */
  uint8_T eventPendingTimeout;
  /* Timeout (measured in mutiples of Xcp_Command_Proc() tick) before EV_CMD_PENDING will be sent. */
  uint8_T numBytesTimestamp;
              /* The number of bytes in the DAQ timestamp (0, 1, 2 or 4).     */
  uint8_T maxOdtEntryLen;
              /* The maximum length of an ODT entry in bytes                  */

#ifdef XCP_ENABLE_CALPAG

  uint8_T numSegs;
              /* The number of segments belonging to the session              */
  Xcp_SegConfig_t* pSegConfigs;
              /* The configuration of the segments belonging to the session   */
  Xcp_SegState_t* pSegStates;
              /* The states of the segments belonging to the session          */

#endif

#ifdef XCP_ENABLE_RESUME

  uint32_T nvStartIdx;
  /* The index within the NV memory region at which we store the session's RESUME data */

#endif

  Xcp_TransportLayer_t transportLayerId;
        /* An identifier for the transport layer associated with this session */
} Xcp_SessionConfig_t;

#if defined __cplusplus || defined _cplusplus

extern "C" {

#endif

  extern Xcp_SessionConfig_t Xcp_SessionConfigs[];
  extern Xcp_Session_t Xcp_Sessions[ XCP_NUM_SESSIONS ];
  extern const uint8_T XCP_NUM_EVENTS;
  extern uint32_T XCP_MSG_RX_ID;

#if defined __cplusplus || defined _cplusplus

}
#endif

/******************************************************************************
 *
 * Prototypes
 *
 ******************************************************************************/
/* Standard commands */
extern uint32_T XCP_FN_TYPE Xcp_CmdConnect ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdDisconnect ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetStatus ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdSynch ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdSetMta ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdUpload ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdBuildChecksum ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdShortUpload ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetId ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetCommModeInfo ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdTransportLayer ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdSetRequest ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetSeed ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdUnlock ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdUser ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );

/* Calibration commands */
extern uint32_T XCP_FN_TYPE Xcp_CmdDownload ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdDownloadNext ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdDownloadMax ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdModifyBits ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );

/* Page switching commands */
extern uint32_T XCP_FN_TYPE Xcp_CmdSetCalPage ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetCalPage ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdCopyCalPage ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetPagProcInfo ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdSetSegmentMode ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetSegmentMode ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );

/* Data acquisition and stimulation commands */
extern uint32_T XCP_FN_TYPE Xcp_CmdClearDaqList ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdSetDaqPtr ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdWriteDaq ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdSetDaqListMode ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetDaqListMode ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdStartStopDaqList ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdStartStopSync ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetDaqClock ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdFreeDaq ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdAllocDaq ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdAllocOdt ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdAllocOdtEntry ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetDaqProcInfo ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetDaqResInfo ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdGetDaqListInfo ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );

/* Flash programming commands */
extern uint32_T XCP_FN_TYPE Xcp_CmdProgramStart ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdProgramClear ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdProgram ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdProgramNext ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdProgramMax ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdProgramReset ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdProgramPrepare ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_CmdProgramFormat ( uint32_T sessionId,
  Xcp_Packet_t* pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T
  * pTxPacketSize );

/* Commands not implemented */
extern uint32_T XCP_FN_TYPE Xcp_CmdUnknown ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
extern uint32_T XCP_FN_TYPE Xcp_DaqProcessor ( const uint32_T daqListId, const
  uint32_T sessionId, Xcp_SessionConfig_t* const pSessionCfg );
extern uint32_T XCP_FN_TYPE Xcp_StimProcessor ( const uint32_T daqListId, const
  uint32_T sessionId, Xcp_SessionConfig_t* const pSessionCfg );
extern void XCP_FN_TYPE Xcp_GetTimestamp ( Xcp_StatePtr8 pTimestamp, uint32_T
  numBytesTimestamp );
extern void XCP_FN_TYPE Xcp_DoDisconnect ( uint32_T sessionId, Xcp_Session_t*
  pSession );
extern void XCP_FN_TYPE Xcp_ResetDaqList ( uint32_T sessionId, uint32_T
  daqListId );

/* If we do not support "seed and key" functionality we remap all "seed and key" commands to XcpCmdUnknown() */
#ifndef XCP_ENABLE_SEEDNKEY
#define Xcp_CmdUnlock                  Xcp_CmdUnknown
#define Xcp_CmdGetSeed                 Xcp_CmdUnknown
#endif                                 /* !XCP_ENABLE_SEEDNKEY */

/* If we do not support the PGM resource we remap all PGM commands to XcpCmdUnknown() */
#ifndef XCP_ENABLE_PGM
#define Xcp_CmdProgramStart            Xcp_CmdUnknown
#define Xcp_CmdProgramClear            Xcp_CmdUnknown
#define Xcp_CmdProgram                 Xcp_CmdUnknown
#define Xcp_CmdProgramNext             Xcp_CmdUnknown
#define Xcp_CmdProgramMax              Xcp_CmdUnknown
#define Xcp_CmdProgramReset            Xcp_CmdUnknown
#define Xcp_CmdProgramPrepare          Xcp_CmdUnknown
#define Xcp_CmdProgramFormat           Xcp_CmdUnknown
#endif                                 /* !XCP_ENABLE_PGM */

/* If we do not support the CALPAG resource we remap all CALPAG commands to XcpCmdUnknown() */
#ifndef XCP_ENABLE_CALPAG
#define Xcp_CmdSetCalPage              Xcp_CmdUnknown
#define Xcp_CmdGetCalPage              Xcp_CmdUnknown
#define Xcp_CmdCopyCalPage             Xcp_CmdUnknown
#define Xcp_CmdGetPagProcInfo          Xcp_CmdUnknown
#define Xcp_CmdSetSegmentMode          Xcp_CmdUnknown
#define Xcp_CmdGetSegmentMode          Xcp_CmdUnknown
#define Xcp_CmdDownload                Xcp_CmdUnknown
#define Xcp_CmdDownloadNext            Xcp_CmdUnknown
#define Xcp_CmdDownloadMax             Xcp_CmdUnknown
#define Xcp_CmdModifyBits              Xcp_CmdUnknown
#endif                                 /* !XCP_ENABLE_CALPAG */

/* If we do not support page freezing we remap the associated functions to XcpCmdUnknown() */
#ifndef XCP_ENABLE_PAGEFREEZE
#define Xcp_CmdSetSegmentMode          Xcp_CmdUnknown
#define Xcp_CmdGetSegmentMode          Xcp_CmdUnknown
#endif                                 /* !XCP_ENABLE_PAGEFREEZE */

/* If we do not support various optional commands we remap them to XcpCmdUnknown() */
#ifndef XCP_ENABLE_OPTIONAL_CMDS
#define Xcp_CmdDownloadMax             Xcp_CmdUnknown
#define Xcp_CmdGetCommModeInfo         Xcp_CmdUnknown
#define Xcp_CmdGetDaqListInfo          Xcp_CmdUnknown
#define Xcp_CmdGetDaqProcInfo          Xcp_CmdUnknown
#define Xcp_CmdGetDaqResInfo           Xcp_CmdUnknown
#define Xcp_CmdGetId                   Xcp_CmdUnknown
#define Xcp_CmdGetPagProcInfo          Xcp_CmdUnknown
#define Xcp_CmdProgramFormat           Xcp_CmdUnknown
#define Xcp_CmdProgramMax              Xcp_CmdUnknown
#define Xcp_CmdProgramPrepare          Xcp_CmdUnknown
#define Xcp_CmdShortUpload             Xcp_CmdUnknown
#define Xcp_CmdGetDaqListMode          Xcp_CmdUnknown
#endif                                 /* !XCP_ENABLE_OPTIONAL_CMDS */

/* If we do not support dynamic DAQ lists we remap all dynamic DAQ commands to XcpCmdUnknown() */
#ifndef XCP_ENABLE_DYNDAQ
#define Xcp_CmdAllocDaq                Xcp_CmdUnknown
#define Xcp_CmdAllocOdt                Xcp_CmdUnknown
#define Xcp_CmdFreeDaq                 Xcp_CmdUnknown
#define Xcp_CmdAllocOdtEntry           Xcp_CmdUnknown
#endif                                 /* !XCP_ENABLE_DYNDAQ */

/* If we support neither RESUME nor page freezing we remap SET_REQUEST to XcpCmdUnknown() */
#if !defined( XCP_ENABLE_PAGEFREEZE ) && !defined( XCP_ENABLE_RESUME )
#define Xcp_CmdSetRequest              Xcp_CmdUnknown
#endif                        /* !XCP_ENABLE_PAGEFREEZE && !XCP_ENABLE_RESUME */

/* If we do not support USER_CMD we remap USER_CMD to XcpCmdUnknown() */
#if !defined( XCP_ENABLE_USER_CMD )
#define Xcp_CmdUser                    Xcp_CmdUnknown
#endif                                 /* !XCP_ENABLE_USER_CMD */

void XCP_FN_TYPE XcpCan_Initialize ( void );
Xcp_StatePtr8 XCP_FN_TYPE XcpCan_GetRxBuf ( uint32_T sessionId, uint32_T
  channelId );
Xcp_StatePtr8 XCP_FN_TYPE XcpCan_PeekRxBuf ( uint32_T sessionId, uint32_T
  channelId, uint32_T peekIdx );
void XCP_FN_TYPE XcpCan_RxNext ( uint32_T sessionId, uint32_T channelId );
Xcp_StatePtr8 XCP_FN_TYPE XcpCan_GetTxBuf ( uint32_T sessionId, uint32_T
  channelId );
void XCP_FN_TYPE XcpCan_TxNext ( uint32_T sessionId, uint32_T channelId,
  uint32_T bufferLen );
uint32_T XCP_FN_TYPE XcpCan_CmdProc ( uint32_T sessionId, Xcp_Packet_t*
  pRxPacket, Xcp_Packet_t* pTxPacket, uint32_T prevCmd, uint32_T* pTxPacketSize );
uint32_T XCP_FN_TYPE XcpCan_PrepareResume ( uint32_T sessionId, uint32_T
  daqListId, uint32_T nvIdx );
uint32_T XCP_FN_TYPE XcpCan_DoResume ( uint32_T sessionId, uint32_T daqListId,
  uint32_T nvIdx );
void XCP_FN_TYPE XcpCan_ResetDaqList ( uint32_T sessionId, uint32_T daqListId );

/* Return values for Xcp_Event() */
#define XCPEVENT_DAQSTIM_NOT_EXECUTED  0x00
#define XCPEVENT_DAQ_OVERLOAD          0x01
#define XCPEVENT_DTO_OVERFILL          0x02
#define XCPEVENT_MISSING_DTO           0x04
#define XCPEVENT_DAQSTIM_EXECUTED      0x08

/*
 * Define function-like macros
 */
#ifndef Xcp_DoStimForEvent
#ifdef XCP_ENABLE_STIM
#define Xcp_DoStimForEvent(                                      /* uint32_T */eventId ) ( Xcp_Event( eventId, 1 ) )
#else
#define Xcp_DoStimForEvent(                                      /* uint32_T */eventId ) /* Do nothing */
#endif
#endif

#ifndef Xcp_DoDaqForEvent
#define Xcp_DoDaqForEvent(                                       /* uint32_T */eventId ) ( Xcp_Event( eventId, 0 ) )
#endif

/*
 * Declare public functions
 */
#if defined __cplusplus || defined _cplusplus

extern "C" {

#endif

  void XCP_FN_TYPE Xcp_Initialize ( void );
  void XCP_FN_TYPE Xcp_CmdProcessor ( void );
  uint32_T XCP_FN_TYPE Xcp_Event ( uint32_T eventId, uint32_T isStim );

#if defined __cplusplus || defined _cplusplus

}
#endif
#endif                                 /* _XCPCAN_AUTOCONF_H */
